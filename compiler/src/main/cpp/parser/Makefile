# Makefile for Bison Parser

CXX = g++
CXXFLAGS = -std=c++11 -Wall -Wextra -g
BISON = bison
FLEX = flex

# Source files
BISON_SRC = parser.y
LEX_SRC = lexer.l
AST_SRC = ast.cpp
SYMBOL_SRC = symbol.cpp
ANALYZER_SRC = analyzer.cpp
LEXER_SRC = lexer.cpp
JNI_SRC = jni_lexer.cpp
CODEGEN_SRC = codegen_bridge.cpp

# Generated files
BISON_C = parser.tab.c
BISON_H = parser.tab.h
LEX_C = lex.yy.c
JNI_H = compiler_lexer_Lexer.h

# Object files
BISON_OBJ = parser.tab.o
LEX_OBJ = lex.yy.o
AST_OBJ = ast.o
SYMBOL_OBJ = symbol.o
ANALYZER_OBJ = analyzer.o
LEXER_OBJ = lexer.o
JNI_OBJ = jni_lexer.o
CODEGEN_OBJ = codegen_bridge.o

# Shared library
TARGET = libparser.so

# Executable
EXECUTABLE = parser

# JNI includes (adjust path as needed)
JNI_INCLUDES = -I$(JAVA_HOME)/include -I$(JAVA_HOME)/include/linux -I.

all: $(JNI_H) $(TARGET) $(EXECUTABLE)

$(EXECUTABLE): $(BISON_OBJ) $(LEX_OBJ) $(AST_OBJ) $(SYMBOL_OBJ) $(ANALYZER_OBJ) $(LEXER_OBJ) $(JNI_OBJ) $(CODEGEN_OBJ)
	$(CXX) $(CXXFLAGS) -fPIC -o $@ $^ $(JNI_INCLUDES)

$(TARGET): $(BISON_OBJ) $(LEX_OBJ) $(AST_OBJ) $(SYMBOL_OBJ) $(ANALYZER_OBJ) $(LEXER_OBJ) $(JNI_OBJ) $(CODEGEN_OBJ)
	$(CXX) $(CXXFLAGS) -shared -fPIC -Wl,--no-as-needed -o $@ $^ $(JNI_INCLUDES)

$(BISON_C) $(BISON_H): $(BISON_SRC)
	$(BISON) -d $<

$(LEX_C): $(LEX_SRC)
	$(FLEX) $<

$(JNI_H):
	@echo "JNI header file $(JNI_H) should be generated by javac -h"

%.o: %.c
	$(CXX) $(CXXFLAGS) -fPIC -c $< $(JNI_INCLUDES)

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -fPIC -c $< $(JNI_INCLUDES)

ast.o: ast.h
symbol.o: symbol.h ast.h
lexer.o: lexer.h
jni_lexer.o: lexer.h $(JNI_H)
codegen_bridge.o: ast.h symbol.h analyzer.h

clean:
	rm -f $(BISON_C) $(BISON_H) $(LEX_C) $(JNI_H) *.o $(TARGET) $(EXECUTABLE)

.PHONY: all clean
