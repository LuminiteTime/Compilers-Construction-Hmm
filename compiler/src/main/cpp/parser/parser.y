%{
#include <iostream>
#include <vector>
#include <string>
#include <memory>

// Token definitions - let Bison assign values automatically

#include "ast.h"      // AST node definitions
#include "symbol.h"   // Symbol table classes
#include "lexer.h"    // Java lexer interface
#include "analyzer.h" // Semantic analyzer

// External lexer interface functions
extern int yylex();
extern char* yytext;
extern int yylineno;
extern void yyerror(const char* msg);

// Error flag
extern bool hasParseError;
bool hasParseError = false;

// Global symbol table and AST root
SymbolTable* symbolTable;
ProgramNode* astRoot;

// Java lexer integration
JavaLexer* javaLexer;

// yylex is generated by flex from lexer.l

// Utility function declarations
TypeNode* inferType(ExpressionNode* expr);
bool checkAssignmentTypes(ExpressionNode* target, ExpressionNode* value);
bool isBooleanType(ExpressionNode* expr);
bool checkArguments(RoutineInfo* routine, ASTNode* arguments);

// AST Tree Printer
class ASTTreePrinter {
private:
    int indentLevel = 0;

    void printIndent() {
        for (int i = 0; i < indentLevel; ++i) {
            std::cout << "  ";
        }
    }

    void printExpression(ExpressionNode* expr) {
        if (!expr) {
            std::cout << "null";
            return;
        }

        indentLevel++;
        printIndent();

        if (auto intLit = dynamic_cast<IntegerLiteralNode*>(expr)) {
            std::cout << "IntegerLiteral: " << intLit->value << std::endl;
        } else if (auto realLit = dynamic_cast<RealLiteralNode*>(expr)) {
            std::cout << "RealLiteral: " << realLit->value << std::endl;
        } else if (auto boolLit = dynamic_cast<BooleanLiteralNode*>(expr)) {
            std::cout << "BooleanLiteral: " << (boolLit->value ? "true" : "false") << std::endl;
        } else if (auto varAcc = dynamic_cast<VariableAccessNode*>(expr)) {
            std::cout << "VariableAccess: '" << varAcc->name << "'" << std::endl;
        } else if (auto binOp = dynamic_cast<BinaryOpNode*>(expr)) {
            std::string opName;
            switch (binOp->op) {
                case OpKind::PLUS: opName = "+"; break;
                case OpKind::MINUS: opName = "-"; break;
                case OpKind::MUL: opName = "*"; break;
                case OpKind::DIV: opName = "/"; break;
                case OpKind::MOD: opName = "mod"; break;
                case OpKind::EQ: opName = "="; break;
                case OpKind::NE: opName = "!="; break;
                case OpKind::LT: opName = "<"; break;
                case OpKind::GT: opName = ">"; break;
                case OpKind::LE: opName = "<="; break;
                case OpKind::GE: opName = ">="; break;
                case OpKind::AND: opName = "and"; break;
                case OpKind::OR: opName = "or"; break;
                case OpKind::XOR: opName = "xor"; break;
                default: opName = "?"; break;
            }
            std::cout << "BinaryOp: " << opName << std::endl;
            printIndent(); std::cout << "Left:" << std::endl; printExpression(binOp->left);
            printIndent(); std::cout << "Right:" << std::endl; printExpression(binOp->right);
        } else if (auto unOp = dynamic_cast<UnaryOpNode*>(expr)) {
            std::string opName;
            switch (unOp->op) {
                case OpKind::UMINUS: opName = "-"; break;
                case OpKind::UPLUS: opName = "+"; break;
                case OpKind::NOT: opName = "not"; break;
                default: opName = "?"; break;
            }
            std::cout << "UnaryOp: " << opName << std::endl;
            printIndent(); std::cout << "Operand:" << std::endl; printExpression(unOp->operand);
        } else if (auto arrAcc = dynamic_cast<ArrayAccessNode*>(expr)) {
            std::cout << "ArrayAccess" << std::endl;
            indentLevel++;
            printIndent(); std::cout << "Array:" << std::endl; printExpression(arrAcc->array);
            printIndent(); std::cout << "Index:" << std::endl; printExpression(arrAcc->index);
            indentLevel--;
        } else if (auto fieldAcc = dynamic_cast<FieldAccessNode*>(expr)) {
            std::cout << "FieldAccess" << std::endl;
            indentLevel++;
            printIndent(); std::cout << "Record:" << std::endl; printExpression(fieldAcc->record);
            printIndent(); std::cout << "Field: '" << fieldAcc->fieldName << "'" << std::endl;
            indentLevel--;
        } else if (auto routineCall = dynamic_cast<RoutineCallNode*>(expr)) {
            std::cout << "RoutineCall: '" << routineCall->name << "'" << std::endl;
            if (auto argList = dynamic_cast<ArgumentListNode*>(routineCall->arguments)) {
                if (!argList->arguments.empty()) {
                    indentLevel++;
                    printIndent(); std::cout << "Arguments:" << std::endl;
                    for (size_t i = 0; i < argList->arguments.size(); ++i) {
                        indentLevel++;
                        printIndent(); std::cout << "Arg " << (i+1) << ":" << std::endl;
                        printExpression(argList->arguments[i]);
                        indentLevel--;
                    }
                    indentLevel--;
                }
            }
        } else {
            std::cout << "Unknown expression type" << std::endl;
        }

        indentLevel--;
    }

private:
    void printRange(ASTNode* rangeNode) {
        if (auto range = dynamic_cast<RangeNode*>(rangeNode)) {
            if (range->end) {
                // Normal range: start .. end
                printExpression(range->start);
                std::cout << " .. ";
                printExpression(range->end);
            } else {
                // Array iteration: just the array expression
                printExpression(range->start);
            }
        } else if (auto expr = dynamic_cast<ExpressionNode*>(rangeNode)) {
            // For other range types, show the expression directly
            printExpression(expr);
        } else {
            std::cout << "[Complex range expression]";
        }
    }

    void printBody(ASTNode* bodyNode, int baseIndent) {
        if (auto body = dynamic_cast<BodyNode*>(bodyNode)) {
            // Save current indent level
            int savedIndent = indentLevel;

            indentLevel = baseIndent;
            printIndent(); std::cout << "Declarations in body (" << body->declarations.size() << "):" << std::endl;
            if (!body->declarations.empty()) {
                for (size_t i = 0; i < body->declarations.size(); ++i) {
                    indentLevel = baseIndent + 1;
                    printIndent(); std::cout << "Local Declaration " << (i+1) << ":" << std::endl;
                    // Simplified declaration printing for body
                    indentLevel = baseIndent + 2;
                    printIndent(); std::cout << "[Local declaration details]" << std::endl;
                }
            }

            indentLevel = baseIndent;
            printIndent(); std::cout << "Statements in body (" << body->statements.size() << "):" << std::endl;
            if (!body->statements.empty()) {
                for (size_t i = 0; i < body->statements.size(); ++i) {
                    indentLevel = baseIndent + 1;
                    printIndent(); std::cout << "Body Statement " << (i+1) << ":" << std::endl;

                    if (auto assignStmt = dynamic_cast<AssignmentNode*>(body->statements[i])) {
                        indentLevel = baseIndent + 2;
                        printIndent(); std::cout << "Assignment" << std::endl;
                        indentLevel = baseIndent + 3;
                        printIndent(); std::cout << "Target:" << std::endl;
                        printExpression(assignStmt->target);
                        printIndent(); std::cout << "Value:" << std::endl;
                        printExpression(assignStmt->value);
                    } else if (auto routineCallStmt = dynamic_cast<RoutineCallStatementNode*>(body->statements[i])) {
                        indentLevel = baseIndent + 2;
                        printIndent(); std::cout << "RoutineCallStatement" << std::endl;
                        indentLevel = baseIndent + 3;
                        printIndent(); std::cout << "Routine: '" << routineCallStmt->name << "'" << std::endl;
                    } else if (auto printStmt = dynamic_cast<PrintStatementNode*>(body->statements[i])) {
                        indentLevel = baseIndent + 2;
                        printIndent(); std::cout << "PrintStatement" << std::endl;
                        indentLevel = baseIndent + 3;
                        printIndent(); std::cout << "Arguments:" << std::endl;
                        if (auto exprList = dynamic_cast<ExpressionListNode*>(printStmt->expressions)) {
                            for (size_t j = 0; j < exprList->expressions.size(); ++j) {
                                indentLevel = baseIndent + 4;
                                printIndent(); std::cout << "Arg " << (j+1) << ":" << std::endl;
                                printExpression(exprList->expressions[j]);
                            }
                        }
                    } else {
                        indentLevel = baseIndent + 2;
                        printIndent(); std::cout << "[Other statement type]" << std::endl;
                    }
                }
            } else {
                indentLevel = baseIndent + 1;
                printIndent(); std::cout << "(no statements)" << std::endl;
            }

            // Restore indent level
            indentLevel = savedIndent;
        } else {
            printIndent(); std::cout << "Invalid body" << std::endl;
        }
    }

public:
    void printTree(ProgramNode* root) {
        std::cout << "=== AST TREE STRUCTURE ===" << std::endl;

        if (!root) {
            std::cout << "Empty program" << std::endl;
            return;
        }

        std::cout << "Program" << std::endl;
        indentLevel = 1;

        // Print declarations
        if (!root->declarations.empty()) {
            printIndent(); std::cout << "Declarations:" << std::endl;
            for (size_t i = 0; i < root->declarations.size(); ++i) {
                indentLevel++;
                printIndent(); std::cout << "Declaration " << (i+1) << ":" << std::endl;

                auto decl = root->declarations[i];
                if (auto varDecl = dynamic_cast<VariableDeclarationNode*>(decl)) {
                    indentLevel++;
                    printIndent(); std::cout << "VariableDeclaration" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Name: '" << varDecl->name << "'" << std::endl;

                    if (varDecl->type) {
                        printIndent();
                        if (auto primType = dynamic_cast<PrimitiveTypeNode*>(varDecl->type)) {
                            std::cout << "Type: ";
                            switch (primType->kind) {
                                case TypeKind::INTEGER: std::cout << "integer"; break;
                                case TypeKind::REAL: std::cout << "real"; break;
                                case TypeKind::BOOLEAN: std::cout << "boolean"; break;
                            }
                            std::cout << std::endl;
                        } else if (auto arrType = dynamic_cast<ArrayTypeNode*>(varDecl->type)) {
                            std::cout << "Type: array[" << arrType->size << "] of ";
                            if (auto elemPrim = dynamic_cast<PrimitiveTypeNode*>(arrType->elementType)) {
                                switch (elemPrim->kind) {
                                    case TypeKind::INTEGER: std::cout << "integer"; break;
                                    case TypeKind::REAL: std::cout << "real"; break;
                                    case TypeKind::BOOLEAN: std::cout << "boolean"; break;
                                }
                            } else {
                                std::cout << "complex";
                            }
                            std::cout << std::endl;
                        } else if (auto recType = dynamic_cast<RecordTypeNode*>(varDecl->type)) {
                            std::cout << "Type: record" << std::endl;
                        } else {
                            std::cout << "Type: complex" << std::endl;
                        }
                    }

                    if (varDecl->initializer) {
                        printIndent(); std::cout << "Initializer:" << std::endl;
                        printExpression(varDecl->initializer);
                    } else {
                        printIndent(); std::cout << "Initializer: none" << std::endl;
                    }
                    indentLevel -= 2;
                } else if (auto typeDecl = dynamic_cast<TypeDeclarationNode*>(decl)) {
                    indentLevel++;
                    printIndent(); std::cout << "TypeDeclaration" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Name: '" << typeDecl->name << "'" << std::endl;
                    if (auto recType = dynamic_cast<RecordTypeNode*>(typeDecl->type)) {
                        printIndent(); std::cout << "Type: record" << std::endl;
                        if (auto recBody = dynamic_cast<RecordBodyNode*>(recType->body)) {
                            indentLevel++;
                            printIndent(); std::cout << "Fields:" << std::endl;
                            for (auto field : recBody->fields) {
                                if (auto varField = dynamic_cast<VariableDeclarationNode*>(field)) {
                                    indentLevel++;
                                    printIndent(); std::cout << "Field '" << varField->name << "': ";
                                    if (auto primType = dynamic_cast<PrimitiveTypeNode*>(varField->type)) {
                                        switch (primType->kind) {
                                            case TypeKind::INTEGER: std::cout << "integer"; break;
                                            case TypeKind::REAL: std::cout << "real"; break;
                                            case TypeKind::BOOLEAN: std::cout << "boolean"; break;
                                        }
                                    }
                                    std::cout << std::endl;
                                    indentLevel--;
                                }
                            }
                            indentLevel--;
                        }
                    }
                    indentLevel -= 2;
                } else if (auto routineDecl = dynamic_cast<RoutineDeclarationNode*>(decl)) {
                    indentLevel++;
                    printIndent(); std::cout << "RoutineDeclaration" << std::endl;
                    if (auto routHeader = dynamic_cast<RoutineHeaderNode*>(routineDecl->header)) {
                        indentLevel++;
                        printIndent(); std::cout << "Name: '" << routHeader->name << "'" << std::endl;

                        // Show parameters
                        if (auto paramList = dynamic_cast<ParameterListNode*>(routHeader->parameters)) {
                            printIndent(); std::cout << "Parameters (" << paramList->parameters.size() << "):" << std::endl;
                            for (size_t i = 0; i < paramList->parameters.size(); ++i) {
                                if (auto paramDecl = dynamic_cast<ParameterDeclarationNode*>(paramList->parameters[i])) {
                                    indentLevel++;
                                    printIndent(); std::cout << "Param " << (i+1) << ": '" << paramDecl->name << "' (";
                                    if (auto primType = dynamic_cast<PrimitiveTypeNode*>(paramDecl->type)) {
                                        switch (primType->kind) {
                                            case TypeKind::INTEGER: std::cout << "integer"; break;
                                            case TypeKind::REAL: std::cout << "real"; break;
                                            case TypeKind::BOOLEAN: std::cout << "boolean"; break;
                                        }
                                    }
                                    std::cout << ")" << std::endl;
                                    indentLevel--;
                                }
                            }
                        }

                        // Show return type
                        printIndent(); std::cout << "Return type: ";
                        if (routHeader->returnType) {
                            if (auto primType = dynamic_cast<PrimitiveTypeNode*>(routHeader->returnType)) {
                                switch (primType->kind) {
                                    case TypeKind::INTEGER: std::cout << "integer"; break;
                                    case TypeKind::REAL: std::cout << "real"; break;
                                    case TypeKind::BOOLEAN: std::cout << "boolean"; break;
                                }
                            }
                        } else {
                            std::cout << "void";
                        }
                        std::cout << std::endl;
                        indentLevel--;
                    }

                    // Show function body
                    if (auto routBody = dynamic_cast<RoutineBodyNode*>(routineDecl->body)) {
                        indentLevel++;
                        printIndent(); std::cout << "Body:" << std::endl;
                        if (auto expr = dynamic_cast<ExpressionNode*>(routBody->body)) {
                            // Function with expression body ( => syntax)
                            indentLevel++;
                            printIndent(); std::cout << "Expression: " << std::endl;
                            printExpression(expr);
                            indentLevel--;
                        } else if (auto body = dynamic_cast<BodyNode*>(routBody->body)) {
                            // Function with statement body
                            printBody(body, indentLevel + 1);
                        }
                        indentLevel--;
                    }

                    indentLevel -= 2;
                }

                indentLevel--;
            }
        }

        // Print statements
        if (!root->statements.empty()) {
            printIndent(); std::cout << "Statements:" << std::endl;
            for (size_t i = 0; i < root->statements.size(); ++i) {
                indentLevel++;
                printIndent(); std::cout << "Statement " << (i+1) << ":" << std::endl;

                if (auto assignStmt = dynamic_cast<AssignmentNode*>(root->statements[i])) {
                    indentLevel++;
                    printIndent(); std::cout << "Assignment" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Target:" << std::endl;
                    printExpression(assignStmt->target);
                    printIndent(); std::cout << "Value:" << std::endl;
                    printExpression(assignStmt->value);
                    indentLevel -= 2;
                } else if (auto routineCallStmt = dynamic_cast<RoutineCallStatementNode*>(root->statements[i])) {
                    indentLevel++;
                    printIndent(); std::cout << "RoutineCallStatement" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Routine: '" << routineCallStmt->name << "'" << std::endl;
                    if (auto argList = dynamic_cast<ArgumentListNode*>(routineCallStmt->arguments)) {
                        if (!argList->arguments.empty()) {
                            printIndent(); std::cout << "Arguments:" << std::endl;
                            for (size_t j = 0; j < argList->arguments.size(); ++j) {
                                indentLevel++;
                                printIndent(); std::cout << "Arg " << (j+1) << ":" << std::endl;
                                printExpression(argList->arguments[j]);
                                indentLevel--;
                            }
                        }
                    }
                    indentLevel -= 2;
                } else if (auto whileStmt = dynamic_cast<WhileLoopNode*>(root->statements[i])) {
                    indentLevel++;
                    printIndent(); std::cout << "WhileLoop" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Condition:" << std::endl;
                    printExpression(whileStmt->condition);
                    printIndent(); std::cout << "Body:" << std::endl;
                    printBody(whileStmt->body, indentLevel + 1);
                    indentLevel -= 2;
                } else if (auto forStmt = dynamic_cast<ForLoopNode*>(root->statements[i])) {
                    indentLevel++;
                    printIndent(); std::cout << "ForLoop" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Variable: '" << forStmt->loopVar << "'" << std::endl;
                    printIndent(); std::cout << "Range: ";
                    printRange(forStmt->range);
                    std::cout << std::endl;
                    printIndent(); std::cout << "Reverse: " << (forStmt->reverse ? "true" : "false") << std::endl;
                    printIndent(); std::cout << "Body:" << std::endl;
                    printBody(forStmt->body, indentLevel + 1);
                    indentLevel -= 2;
                } else if (auto ifStmt = dynamic_cast<IfStatementNode*>(root->statements[i])) {
                    indentLevel++;
                    printIndent(); std::cout << "IfStatement" << std::endl;
                    indentLevel++;
                    printIndent(); std::cout << "Condition:" << std::endl;
                    printExpression(ifStmt->condition);
                    printIndent(); std::cout << "Then branch:" << std::endl;
                    printBody(ifStmt->thenBody, indentLevel + 1);
                    if (ifStmt->elseBody) {
                        printIndent(); std::cout << "Else branch:" << std::endl;
                        printBody(ifStmt->elseBody, indentLevel + 1);
                    }
                    indentLevel -= 2;
                } else if (auto printStmt = dynamic_cast<PrintStatementNode*>(root->statements[i])) {
                    indentLevel++;
                    printIndent(); std::cout << "PrintStatement" << std::endl;
                    if (auto exprList = dynamic_cast<ExpressionListNode*>(printStmt->expressions)) {
                        if (!exprList->expressions.empty()) {
                            indentLevel++;
                            printIndent(); std::cout << "Expressions:" << std::endl;
                            for (size_t j = 0; j < exprList->expressions.size(); ++j) {
                                indentLevel++;
                                printIndent(); std::cout << "Expr " << (j+1) << ":" << std::endl;
                                printExpression(exprList->expressions[j]);
                                indentLevel--;
                            }
                            indentLevel--;
                        }
                    }
                    indentLevel--;
                } else {
                    indentLevel++;
                    printIndent(); std::cout << "Unknown statement type" << std::endl;
                    indentLevel--;
                }

                indentLevel--;
            }
        } else {
            printIndent(); std::cout << "Statements: none" << std::endl;
        }

        std::cout << "==============================" << std::endl;
    }
};

// WASM Generator stub
class WASMGenerator {
public:
    void generate(ProgramNode* root) {
        // Skip analyzer for now - semantic analysis happens in Java codegen
        // Analyzer analyzer(/*enableOptimizations=*/false);
        // Analyzer::Result res = analyzer.analyze(root);
        // ... error reporting ...

        std::cout << "AST generated successfully" << std::endl;

        // Optional: print AST for debugging
        // ASTTreePrinter printer;
        // printer.printTree(root);
    }
};
%}

%union {
    int intVal;
    double realVal;
    bool boolVal;
    char* strVal;
    ASTNode* node;
    TypeNode* typeNode;
    ExpressionNode* exprNode;
    StatementNode* stmtNode;
    DeclarationNode* declNode;
}

// Token definitions (let Bison assign values)
%token <strVal> TOK_IDENTIFIER TOK_STRING_LITERAL
%token <intVal> TOK_INTEGER_LITERAL
%token <realVal> TOK_REAL_LITERAL
%token TOK_VAR TOK_TYPE TOK_IS TOK_INTEGER TOK_REAL TOK_BOOLEAN
%token TOK_ARRAY TOK_RECORD TOK_END
%token TOK_WHILE TOK_LOOP TOK_FOR TOK_IN TOK_REVERSE
%token TOK_IF TOK_THEN TOK_ELSE TOK_PRINT TOK_ROUTINE
%token TOK_TRUE TOK_FALSE TOK_AND TOK_OR TOK_XOR TOK_NOT
%token TOK_ASSIGN TOK_DOTDOT TOK_PLUS TOK_MINUS TOK_MULTIPLY TOK_DIVIDE TOK_MODULO
%token TOK_LESS TOK_LESS_EQUAL TOK_GREATER TOK_GREATER_EQUAL TOK_EQUAL TOK_NOT_EQUAL
%token TOK_COLON TOK_SEMICOLON TOK_COMMA TOK_DOT TOK_LPAREN TOK_RPAREN
%token TOK_LBRACKET TOK_RBRACKET TOK_ARROW

// Non-terminal type declarations
%type <node> program top_level_list
%type <declNode> declaration simple_declaration
%type <declNode> variable_declaration type_declaration routine_declaration
%type <typeNode> type primitive_type user_type array_type record_type
%type <node> record_body routine_header parameters parameter_list
%type <node> parameter_declaration routine_body
%type <stmtNode> statement assignment routine_call_statement
%type <stmtNode> while_loop for_loop if_statement print_statement
%type <node> body range
%type <exprNode> expression relation simple factor summand primary
%type <exprNode> or_expr xor_expr and_expr
%type <exprNode> modifiable_primary routine_call
%type <node> expression_list argument_list

// Precedence and associativity (lowest to highest)
%left TOK_OR
%left TOK_XOR
%left TOK_AND
%left TOK_EQUAL TOK_NOT_EQUAL
%left TOK_LESS TOK_LESS_EQUAL TOK_GREATER TOK_GREATER_EQUAL
%left TOK_PLUS TOK_MINUS
%left TOK_MULTIPLY TOK_DIVIDE TOK_MODULO
%right TOK_NOT  // unary operators
%right UMINUS UPLUS  // unary minus/plus

%%

program: top_level_list { $$ = $1; astRoot = (ProgramNode*)$$; }
       ;

top_level_list: /* empty */ { $$ = new ProgramNode(); }
              | top_level_list declaration { $$ = $1; ((ProgramNode*)$$)->addDeclaration($2); }
              | top_level_list declaration TOK_SEMICOLON { $$ = $1; ((ProgramNode*)$$)->addDeclaration($2); }
              | top_level_list statement { $$ = $1; ((ProgramNode*)$$)->addStatement($2); }
              | top_level_list statement TOK_SEMICOLON { $$ = $1; ((ProgramNode*)$$)->addStatement($2); }
              ;

declaration: simple_declaration { $$ = $1; }
           | routine_declaration { $$ = $1; }
           ;

simple_declaration: variable_declaration { $$ = $1; }
                  | type_declaration { $$ = $1; }
                  ;

variable_declaration: TOK_VAR TOK_IDENTIFIER TOK_COLON type {
                        $$ = new VariableDeclarationNode($2, $4, nullptr);
                        // symbolTable->declareVariable($2, $4); // Disabled for Java codegen
                    }
                    | TOK_VAR TOK_IDENTIFIER TOK_COLON type TOK_IS expression {
                        $$ = new VariableDeclarationNode($2, $4, $6);
                        // symbolTable->declareVariable($2, $4); // Disabled for Java codegen
                    }
                    | TOK_VAR TOK_IDENTIFIER TOK_IS expression {
                        TypeNode* inferredType = inferType($4);
                        $$ = new VariableDeclarationNode($2, inferredType, $4);
                        // symbolTable->declareVariable($2, inferredType); // Disabled for Java codegen
                    }
                    ;

type_declaration: TOK_TYPE TOK_IDENTIFIER TOK_IS type {
                    $$ = new TypeDeclarationNode($2, $4);
                    // symbolTable->declareType($2, $4); // Disabled for Java codegen
                }
                ;

type: primitive_type { $$ = $1; }
    | user_type { $$ = $1; }
    | TOK_IDENTIFIER {
        // $$ = symbolTable->lookupType($1); // Disabled for Java codegen
        $$ = new TypeNameNode($1); // Simplified
        // if (!$$) yyerror("Undefined type"); // Disabled for Java codegen
    }
    ;

primitive_type: TOK_INTEGER { $$ = new PrimitiveTypeNode(TypeKind::INTEGER); }
              | TOK_REAL { $$ = new PrimitiveTypeNode(TypeKind::REAL); }
              | TOK_BOOLEAN { $$ = new PrimitiveTypeNode(TypeKind::BOOLEAN); }
              ;

user_type: array_type { $$ = $1; }
         | record_type { $$ = $1; }
         ;

array_type: TOK_ARRAY TOK_LBRACKET expression TOK_RBRACKET type {
              $$ = new ArrayTypeNode((ExpressionNode*)$3, (TypeNode*)$5);
          }
          | TOK_ARRAY TOK_LBRACKET TOK_RBRACKET type {
              $$ = new ArrayTypeNode(nullptr, (TypeNode*)$4);  // sizeless
          }
          ;

record_type: TOK_RECORD record_body TOK_END {
               $$ = new RecordTypeNode($2);
           }
           ;

record_body: /* empty */ { $$ = new RecordBodyNode(); }
           | record_body variable_declaration {
               $$ = $1;
               ((RecordBodyNode*)$$)->addField($2);
           }
           | record_body variable_declaration TOK_SEMICOLON {
               $$ = $1;
               ((RecordBodyNode*)$$)->addField($2);
           }
           ;

routine_declaration: routine_header {
                       $$ = new RoutineDeclarationNode($1, nullptr);
                   }
                   | routine_header routine_body {
                       $$ = new RoutineDeclarationNode($1, $2);
                       symbolTable->declareRoutine($1);
                   }
                   ;

routine_header: TOK_ROUTINE TOK_IDENTIFIER TOK_LPAREN parameters TOK_RPAREN {
                  $$ = new RoutineHeaderNode($2, $4, nullptr);
                  // Declare parameters in current scope for => syntax
                  declareParameters($4);
              }
              | TOK_ROUTINE TOK_IDENTIFIER TOK_LPAREN parameters TOK_RPAREN TOK_COLON type {
                  $$ = new RoutineHeaderNode($2, $4, $7);
                  // Declare parameters in current scope for => syntax
                  declareParameters($4);
              }
              ;

parameters: /* empty */ { $$ = new ParameterListNode(); }
          | parameter_list { $$ = $1; }
          ;

parameter_list: parameter_declaration {
                  $$ = new ParameterListNode();
                  ((ParameterListNode*)$$)->addParameter($1);
              }
              | parameter_list TOK_COMMA parameter_declaration {
                  $$ = $1;
                  ((ParameterListNode*)$$)->addParameter($3);
              }
              ;

parameter_declaration: TOK_IDENTIFIER TOK_COLON type {
                        $$ = new ParameterDeclarationNode($1, $3);
                     }
                     ;

routine_body: TOK_IS body TOK_END { $$ = new RoutineBodyNode($2); }
            | TOK_ARROW expression { $$ = new RoutineBodyNode($2); }
            ;

statement: assignment { $$ = $1; }
         | routine_call_statement { $$ = $1; }
         | while_loop { $$ = $1; }
         | for_loop { $$ = $1; }
         | if_statement { $$ = $1; }
         | print_statement { $$ = $1; }
         ;

assignment: modifiable_primary TOK_ASSIGN expression {
              // Type checking for assignment
              if (!checkAssignmentTypes($1, $3)) {
                  yyerror("Type mismatch in assignment");
              }
              $$ = new AssignmentNode($1, $3);
          }
          ;

routine_call_statement: TOK_IDENTIFIER TOK_LPAREN argument_list TOK_RPAREN {
                          RoutineInfo* routine = symbolTable->lookupRoutine($1);
                          if (!routine) yyerror("Undefined routine");
                          if (!checkArguments(routine, $3)) {
                              yyerror("Argument mismatch");
                          }
                          $$ = new RoutineCallStatementNode($1, $3);
                      }
                      ;

argument_list: /* empty */ { $$ = new ArgumentListNode(); }
             | expression_list { $$ = $1; }
             ;

while_loop: TOK_WHILE expression TOK_LOOP body TOK_END {
              if (!isBooleanType($2)) yyerror("While condition must be boolean");
              $$ = new WhileLoopNode($2, $4);
          }
          ;

for_loop: TOK_FOR TOK_IDENTIFIER TOK_IN range TOK_LOOP { symbolTable->declareVariable($2, new PrimitiveTypeNode(TypeKind::INTEGER)); } body TOK_END {
            $$ = new ForLoopNode($2, $4, false, $7);
        }
        | TOK_FOR TOK_IDENTIFIER TOK_IN range TOK_REVERSE TOK_LOOP { symbolTable->declareVariable($2, new PrimitiveTypeNode(TypeKind::INTEGER)); } body TOK_END {
            $$ = new ForLoopNode($2, $4, true, $8);
        }
        ;

range: expression { $$ = new RangeNode($1, nullptr); }
     | expression TOK_DOTDOT expression { $$ = new RangeNode($1, $3); }
     ;

if_statement: TOK_IF expression TOK_THEN body TOK_END {
                if (!isBooleanType($2)) yyerror("If condition must be boolean");
                $$ = new IfStatementNode($2, $4, nullptr);
            }
            | TOK_IF expression TOK_THEN body TOK_ELSE body TOK_END {
                if (!isBooleanType($2)) yyerror("If condition must be boolean");
                $$ = new IfStatementNode($2, $4, $6);
            }
            ;

print_statement: TOK_PRINT expression_list { $$ = new PrintStatementNode($2); }
               ;

body: /* empty */ { $$ = new BodyNode(); symbolTable->enterScope(); }
    | body simple_declaration TOK_SEMICOLON {
        $$ = $1;
        ((BodyNode*)$$)->addDeclaration($2);
    }
    | body statement TOK_SEMICOLON {
        $$ = $1;
        ((BodyNode*)$$)->addStatement($2);
    }
    ;

expression: or_expr { $$ = $1; }
      ;

// Boolean precedence: not > and > xor > or
or_expr: xor_expr { $$ = $1; }
       | or_expr TOK_OR xor_expr { $$ = new BinaryOpNode(OpKind::OR, $1, $3); }
       ;

xor_expr: and_expr { $$ = $1; }
    | xor_expr TOK_XOR and_expr { $$ = new BinaryOpNode(OpKind::XOR, $1, $3); }
    ;

and_expr: relation { $$ = $1; }
    | and_expr TOK_AND relation { $$ = new BinaryOpNode(OpKind::AND, $1, $3); }
    ;

relation: simple { $$ = $1; }
      | relation TOK_LESS simple { $$ = new BinaryOpNode(OpKind::LT, $1, $3); }
      | relation TOK_LESS_EQUAL simple { $$ = new BinaryOpNode(OpKind::LE, $1, $3); }
      | relation TOK_GREATER simple { $$ = new BinaryOpNode(OpKind::GT, $1, $3); }
      | relation TOK_GREATER_EQUAL simple { $$ = new BinaryOpNode(OpKind::GE, $1, $3); }
      | relation TOK_EQUAL simple { $$ = new BinaryOpNode(OpKind::EQ, $1, $3); }
      | relation TOK_NOT_EQUAL simple { $$ = new BinaryOpNode(OpKind::NE, $1, $3); }
        ;

// Adjusted precedence: multiplication/division/modulo bind tighter than addition/subtraction
// simple → handles addition/subtraction
simple: factor { $$ = $1; }
    | simple TOK_PLUS factor { $$ = new BinaryOpNode(OpKind::PLUS, $1, $3); }
    | simple TOK_MINUS factor { $$ = new BinaryOpNode(OpKind::MINUS, $1, $3); }
      ;

// factor → handles multiplication/division/modulo
factor: summand { $$ = $1; }
    | factor TOK_MULTIPLY summand { $$ = new BinaryOpNode(OpKind::MUL, $1, $3); }
    | factor TOK_DIVIDE summand { $$ = new BinaryOpNode(OpKind::DIV, $1, $3); }
    | factor TOK_MODULO summand { $$ = new BinaryOpNode(OpKind::MOD, $1, $3); }
      ;

summand: primary { $$ = $1; }
        ;

primary: TOK_INTEGER_LITERAL { $$ = new IntegerLiteralNode($1); }
       | TOK_REAL_LITERAL { $$ = new RealLiteralNode($1); }
       | TOK_STRING_LITERAL { $$ = new StringLiteralNode($1); }
       | TOK_TRUE { $$ = new BooleanLiteralNode(true); }
       | TOK_FALSE { $$ = new BooleanLiteralNode(false); }
       | modifiable_primary { $$ = $1; }
       | routine_call { $$ = $1; }
       | TOK_LPAREN expression TOK_RPAREN { $$ = $2; }
       | TOK_PLUS primary %prec UPLUS { $$ = new UnaryOpNode(OpKind::UPLUS, $2); }
       | TOK_MINUS primary %prec UMINUS { $$ = new UnaryOpNode(OpKind::UMINUS, $2); }
       | TOK_NOT primary { $$ = new UnaryOpNode(OpKind::NOT, $2); }
       ;

modifiable_primary: TOK_IDENTIFIER {
                      VariableInfo* var = symbolTable->lookupVariable($1);
                      if (!var) yyerror("Undefined variable");
                      $$ = new VariableAccessNode($1, var->type);
                  }
                  | modifiable_primary TOK_DOT TOK_IDENTIFIER {
                      $$ = new FieldAccessNode($1, $3);
                  }
                  | modifiable_primary TOK_LBRACKET expression TOK_RBRACKET {
                      $$ = new ArrayAccessNode($1, $3);
                  }
                  ;

routine_call: TOK_IDENTIFIER TOK_LPAREN argument_list TOK_RPAREN {
                RoutineInfo* routine = symbolTable->lookupRoutine($1);
                if (!routine) {
                    yyerror("Undefined routine");
                    $$ = new RoutineCallNode($1, $3, nullptr);
                } else {
                    if (!checkArguments(routine, $3)) {
                        yyerror("Argument mismatch");
                    }
                    $$ = new RoutineCallNode($1, $3, routine->returnType);
                }
            }
            ;

expression_list: expression {
                   $$ = new ExpressionListNode();
                   ((ExpressionListNode*)$$)->addExpression($1);
               }
               | expression_list TOK_COMMA expression {
                   $$ = $1;
                   ((ExpressionListNode*)$$)->addExpression($3);
               }
               ;

%%

void yyerror(const char* msg) {
    std::cerr << "Parse error at line " << yylineno << ": " << msg << std::endl;
    hasParseError = true;
    // Error recovery logic here
}

int main(int argc, char** argv) {
    // Initialize symbol table and Java lexer integration
    symbolTable = new SymbolTable();
    javaLexer = new JavaLexer();
    hasParseError = false;

    // Set input file if provided
    if (argc > 1) {
        javaLexer->setInputFile(argv[1]);
    }

    // Parse input
    int result = yyparse();

    // Generate output (runs analyzer + prints AST)
    if (result == 0 && astRoot && !hasParseError) {
        WASMGenerator generator;
        generator.generate(astRoot);
    } else {
        std::cout << "Parsing failed" << std::endl;
    }

    // Cleanup AST and other resources
    // Temporarily disable AST cleanup to avoid segfaults
    // if (astRoot) {
    //     delete astRoot;
    //     astRoot = nullptr;
    // }
    if (symbolTable) {
        delete symbolTable;
    }
    if (javaLexer) {
        delete javaLexer;
    }

    return result;
}

bool checkArguments(RoutineInfo* routine, ASTNode* arguments) {
    if (!routine) return false;

    std::vector<ExpressionNode*> args;
    if (auto* argList = dynamic_cast<ArgumentListNode*>(arguments)) {
        args = argList->arguments;
    } else if (auto* exprList = dynamic_cast<ExpressionListNode*>(arguments)) {
        args = exprList->expressions;
    }

    // Check argument count
    if (args.size() != routine->paramTypes.size()) {
        return false;
    }

    // For now, just check count - full type checking happens in analyzer
    return true;
}
