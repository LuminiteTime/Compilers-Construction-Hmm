# Поток работы анализатора и структура кода (Русский)

В этом документе описано, как выполняется семантический анализатор: общий конвейер, порядок фаз, а также подробности по каждому компоненту. Реализация находится в `compiler/src/main/cpp/parser/analyzer.{h,cpp}`, AST — в `ast.h`.

## Общая схема

Вход: разобранный `ProgramNode*` и заполненная таблица символов `SymbolTable`.
Выход: диагностические сообщения (ошибки/предупреждения) и оптимизированный AST, который выводится существующим принтером.

Конвейер (Analyzer::analyze):

1) runChecks(root)
- Обходит объявления и операторы и выполняет немодифицирующие проверки.
- Находит ошибки типов и формы (неверное поле записи, тип индекса массива, небулевы условия, несоответствие типов в присваивании, проблемы вызовов процедур, несоответствие типа возврата в стрелочных функциях).

2) runOptimizations(root) [выполняется только если нет ошибок и включены оптимизации]
- Сворачивает константные выражения в объявлениях и функциях.
- Упрощает управление потоком:
  - Если условие `if` стало константой — разворачивает выбранную ветку.
  - `while` с константой `false` удаляется.
- Поднимает (hoist) объявления из выбранной константной ветки `if` во внешний scope (программа/тело) с проверкой конфликтов имён.
- Немедленно сворачивает инициализаторы поднятых переменных.
- Удаляет неиспользуемые объявления без инициализаторов.

3) Проверка после оптимизаций (safety check)
- Повторно проверяет верхнеуровневые операторы и выражения относительно множества глобальных объявлений.
- Сообщает об использовании неописанных переменных, что может проявиться после устранения «мертвых» ветвей.

Результат возвращается как `Analyzer::Result` с `errors`, `warnings` и `optimizationsApplied`.

## Немодифицирующие проверки (runChecks)

- Инициализатор переменной vs объявленный тип
  - Для переменных с инициализатором вычисляется тип и сверяется с объявленным. Иначе: `error: Type mismatch in variable initializer: <name>`.

- Типы-записи (дубли полей)
  - Внутри `record` запрещены дубли имён полей: `error: Duplicate field '<name>' in type '<TypeName>'`.

- Объявления процедур/функций
  - Функции со стрелочным телом (`=> expr`): тип выражения сравнивается с объявленным типом возврата. Несоответствие даёт `error: Routine '<name>' return type mismatch`.
  - Функции с блочным телом (`is ... end`): проверяются локальные объявления и операторы.

- Операторы
  - Присваивание: проверяются типы цели и значения; при несовместимости — `error: Type mismatch in assignment`.
  - While: условие должно быть булевым; иначе `error: While condition must be boolean`.
  - For:
    - Числовой диапазон: обе границы — целые.
    - Обход массива: выражение диапазона должно быть массивом.
  - If: условие — булево; иначе `error: If condition must be boolean`.
  - Print: проверяются все выражения в списке.
  - Оператор вызова процедуры: существование, арность, совместимость типов параметров.

- Выражения
  - Индекс массива — целый: `error: Array index must be integer`.
  - Статическая проверка границ: если индекс и размер — константы и индекс вне диапазона, предупреждение `warning: Array index <i> out of bounds [1..<N>] (static)`.
  - Доступ к полю записи: базовый тип — запись, поле существует; иначе `error: Field access on non-record type` или `error: Unknown field '<field>' in record`.

## Оптимизации (runOptimizations)

- Свёртка констант (foldExpression)
  - Арифметика: +, -, *, /, mod (при необходимости — продвижение к real).
  - Сравнения: <, <=, >, >=, =, /= сворачиваются в boolean при числовых константах.
  - Логика: and, or, xor сворачиваются для констант.
  - Унарные: +, -, not сворачиваются для константных операндов.

- Упрощение if с подъёмом объявлений
  - Если условие свелось к константе, выбирается соответствующее тело.
  - Перед подъёмом вызывается `simplifyInBody(chosen)`, чтобы сначала развернуть вложенные константные ветви; это поднимает их объявления в `declarations` выбранного тела.
  - Затем объявления выбранного тела поднимаются во внешний scope:
    - На уровне программы: в `ProgramNode::declarations`.
    - На уровне тела: в `BodyNode::declarations`.
  - Инициализаторы поднятых переменных немедленно сворачиваются.
  - Конфликт имён (существует переменная с тем же именем в том же scope) даёт `error: Duplicate variable declaration '<name>' in same scope` (переименования нет).
  - Операторы выбранного тела встраиваются в текущий список операторов (if удаляется).

- Удаление `while false`
  - Если условие свелось к false, цикл удаляется.

- Удаление неиспользуемых объявлений
  - Формируется множество используемых переменных (из операторов и инициализаторов).
  - Удаляются объявления, которые не используются и не имеют инициализатора.

## Проверка после оптимизаций

- Собираются имена глобальных переменных из объявлений уровня программы.
- Сканируются верхнеуровневые операторы; если встречается идентификатор, отсутствующий среди глобальных, сообщение `error: Undefined variable '<name>'`.
- Преднамеренно анализируются только верхнеуровневые операторы, чтобы не давать ложных срабатываний для невыбранных веток.

## Учёт ошибок/предупреждений и оптимизаций

- Ошибки и предупреждения записываются в `Analyzer::Result`.
- `optimizationsApplied` увеличивается при любой фактической модификации AST (свёртка, удаление, разворачивание).

## Порядок фаз и мотивация

- Сначала проверки — затем оптимизации: нельзя преобразовывать заведомо неверную программу.
- Вызов `simplifyInBody(chosen)` перед подъёмом обеспечивает корректный подъём объявлений из вложенных константных if (например, `y` из внутренней ветки не потеряется).
- Финальная проверка защищает от неописанных ссылок, появляющихся после упрощения управления потоком.

## Расширение

- Добавляйте новые проверки в `checkNode`, `checkStatement`, `checkExpression`.
- Добавляйте новые оптимизации в `foldExpression` и семейство `simplify*`.
- Сохраняйте порядок: проверки → оптимизации → защитная проверка.

## Карта ключевых функций

- `Analyzer::analyze` — оркестрация конвейера.
- `runChecks` — вход в фазу проверок.
- `runOptimizations` — свёртка констант и упрощение управления потоком.
- `foldExpression` — движок свёртки выражений.
- `simplifyInProgram` / `simplifyInBody` — преобразование if/while и подъём объявлений.
- `removeUnusedDeclarations` — удаление неиспользуемых переменных (без инициализатора).
- Пост-оптимизационная защитная проверка — неописанные верхнеуровневые ссылки.
